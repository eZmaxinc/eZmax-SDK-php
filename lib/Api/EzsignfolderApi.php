<?php
/**
 * EzsignfolderApi
 * PHP version 7.2
 *
 * @category Class
 * @package  eZmaxAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * eZmax API Definition
 *
 * This API expose all the functionnalities for the eZmax and eZsign application.  We provide SDKs for customers. They are generated using OpenAPI codegen, we encourage customers to use them as we also provide samples for them.  You can choose to build your own implementation manually or can use any compatible OpenAPI 3.0 generator like Swagger Codegen, OpenAPI codegen or any commercial generators.  If you need helping understanding how to use this API, don't waste too much time looging for it. Contact support-api@ezmax.ca, we're here to help. We are developpers so we know programmers don't like bad documentation. If you don't find what you need in the documentation, let us know, we'll improve it and put you rapidly up on track.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support-api@ezmax.ca
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace eZmaxAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use eZmaxAPI\Client\ApiException;
use eZmaxAPI\Client\Configuration;
use eZmaxAPI\Client\HeaderSelector;
use eZmaxAPI\Client\ObjectSerializer;

/**
 * EzsignfolderApi Class Doc Comment
 *
 * @category Class
 * @package  eZmaxAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EzsignfolderApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation objectEzsignfolderCreateObjectV1
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Request[] $objectEzsignfolderCreateObjectV1Request objectEzsignfolderCreateObjectV1Request (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Response
     */
    public function objectEzsignfolderCreateObjectV1($objectEzsignfolderCreateObjectV1Request)
    {
        list($response) = $this->objectEzsignfolderCreateObjectV1WithHttpInfo($objectEzsignfolderCreateObjectV1Request);
        return $response;
    }

    /**
     * Operation objectEzsignfolderCreateObjectV1WithHttpInfo
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Request[] $objectEzsignfolderCreateObjectV1Request (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function objectEzsignfolderCreateObjectV1WithHttpInfo($objectEzsignfolderCreateObjectV1Request)
    {
        $request = $this->objectEzsignfolderCreateObjectV1Request($objectEzsignfolderCreateObjectV1Request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Response' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Response';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation objectEzsignfolderCreateObjectV1Async
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Request[] $objectEzsignfolderCreateObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderCreateObjectV1Async($objectEzsignfolderCreateObjectV1Request)
    {
        return $this->objectEzsignfolderCreateObjectV1AsyncWithHttpInfo($objectEzsignfolderCreateObjectV1Request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation objectEzsignfolderCreateObjectV1AsyncWithHttpInfo
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Request[] $objectEzsignfolderCreateObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderCreateObjectV1AsyncWithHttpInfo($objectEzsignfolderCreateObjectV1Request)
    {
        $returnType = '\eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Response';
        $request = $this->objectEzsignfolderCreateObjectV1Request($objectEzsignfolderCreateObjectV1Request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'objectEzsignfolderCreateObjectV1'
     *
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderCreateObjectV1Request[] $objectEzsignfolderCreateObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function objectEzsignfolderCreateObjectV1Request($objectEzsignfolderCreateObjectV1Request)
    {
        // verify the required parameter 'objectEzsignfolderCreateObjectV1Request' is set
        if ($objectEzsignfolderCreateObjectV1Request === null || (is_array($objectEzsignfolderCreateObjectV1Request) && count($objectEzsignfolderCreateObjectV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $objectEzsignfolderCreateObjectV1Request when calling objectEzsignfolderCreateObjectV1'
            );
        }

        $resourcePath = '/1/object/ezsignfolder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($objectEzsignfolderCreateObjectV1Request)) {
            $_tempBody = $objectEzsignfolderCreateObjectV1Request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation objectEzsignfolderDeleteObjectV1
     *
     * Delete an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Client\Model\ObjectEzsignfolderDeleteObjectV1Response|\eZmaxAPI\Client\Model\GenericResponseError
     */
    public function objectEzsignfolderDeleteObjectV1($pkiEzsignfolderID)
    {
        list($response) = $this->objectEzsignfolderDeleteObjectV1WithHttpInfo($pkiEzsignfolderID);
        return $response;
    }

    /**
     * Operation objectEzsignfolderDeleteObjectV1WithHttpInfo
     *
     * Delete an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Client\Model\ObjectEzsignfolderDeleteObjectV1Response|\eZmaxAPI\Client\Model\GenericResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function objectEzsignfolderDeleteObjectV1WithHttpInfo($pkiEzsignfolderID)
    {
        $request = $this->objectEzsignfolderDeleteObjectV1Request($pkiEzsignfolderID);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Client\Model\ObjectEzsignfolderDeleteObjectV1Response' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Client\Model\ObjectEzsignfolderDeleteObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Client\Model\GenericResponseError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Client\Model\GenericResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Client\Model\ObjectEzsignfolderDeleteObjectV1Response';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Client\Model\ObjectEzsignfolderDeleteObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Client\Model\GenericResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation objectEzsignfolderDeleteObjectV1Async
     *
     * Delete an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderDeleteObjectV1Async($pkiEzsignfolderID)
    {
        return $this->objectEzsignfolderDeleteObjectV1AsyncWithHttpInfo($pkiEzsignfolderID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation objectEzsignfolderDeleteObjectV1AsyncWithHttpInfo
     *
     * Delete an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderDeleteObjectV1AsyncWithHttpInfo($pkiEzsignfolderID)
    {
        $returnType = '\eZmaxAPI\Client\Model\ObjectEzsignfolderDeleteObjectV1Response';
        $request = $this->objectEzsignfolderDeleteObjectV1Request($pkiEzsignfolderID);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'objectEzsignfolderDeleteObjectV1'
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function objectEzsignfolderDeleteObjectV1Request($pkiEzsignfolderID)
    {
        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling objectEzsignfolderDeleteObjectV1'
            );
        }

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation objectEzsignfolderEditObjectV1
     *
     * Modify an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Request $objectEzsignfolderEditObjectV1Request objectEzsignfolderEditObjectV1Request (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Response|\eZmaxAPI\Client\Model\GenericResponseError
     */
    public function objectEzsignfolderEditObjectV1($pkiEzsignfolderID, $objectEzsignfolderEditObjectV1Request)
    {
        list($response) = $this->objectEzsignfolderEditObjectV1WithHttpInfo($pkiEzsignfolderID, $objectEzsignfolderEditObjectV1Request);
        return $response;
    }

    /**
     * Operation objectEzsignfolderEditObjectV1WithHttpInfo
     *
     * Modify an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Request $objectEzsignfolderEditObjectV1Request (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Response|\eZmaxAPI\Client\Model\GenericResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function objectEzsignfolderEditObjectV1WithHttpInfo($pkiEzsignfolderID, $objectEzsignfolderEditObjectV1Request)
    {
        $request = $this->objectEzsignfolderEditObjectV1Request($pkiEzsignfolderID, $objectEzsignfolderEditObjectV1Request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Response' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Client\Model\GenericResponseError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Client\Model\GenericResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Response';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Client\Model\GenericResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation objectEzsignfolderEditObjectV1Async
     *
     * Modify an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Request $objectEzsignfolderEditObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderEditObjectV1Async($pkiEzsignfolderID, $objectEzsignfolderEditObjectV1Request)
    {
        return $this->objectEzsignfolderEditObjectV1AsyncWithHttpInfo($pkiEzsignfolderID, $objectEzsignfolderEditObjectV1Request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation objectEzsignfolderEditObjectV1AsyncWithHttpInfo
     *
     * Modify an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Request $objectEzsignfolderEditObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderEditObjectV1AsyncWithHttpInfo($pkiEzsignfolderID, $objectEzsignfolderEditObjectV1Request)
    {
        $returnType = '\eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Response';
        $request = $this->objectEzsignfolderEditObjectV1Request($pkiEzsignfolderID, $objectEzsignfolderEditObjectV1Request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'objectEzsignfolderEditObjectV1'
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     * @param  \eZmaxAPI\Client\Model\ObjectEzsignfolderEditObjectV1Request $objectEzsignfolderEditObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function objectEzsignfolderEditObjectV1Request($pkiEzsignfolderID, $objectEzsignfolderEditObjectV1Request)
    {
        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling objectEzsignfolderEditObjectV1'
            );
        }
        // verify the required parameter 'objectEzsignfolderEditObjectV1Request' is set
        if ($objectEzsignfolderEditObjectV1Request === null || (is_array($objectEzsignfolderEditObjectV1Request) && count($objectEzsignfolderEditObjectV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $objectEzsignfolderEditObjectV1Request when calling objectEzsignfolderEditObjectV1'
            );
        }

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($objectEzsignfolderEditObjectV1Request)) {
            $_tempBody = $objectEzsignfolderEditObjectV1Request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation objectEzsignfolderGetObjectGetChildrenV1
     *
     * Retrieve an existing Ezsignfolder's children IDs
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function objectEzsignfolderGetObjectGetChildrenV1($pkiEzsignfolderID)
    {
        $this->objectEzsignfolderGetObjectGetChildrenV1WithHttpInfo($pkiEzsignfolderID);
    }

    /**
     * Operation objectEzsignfolderGetObjectGetChildrenV1WithHttpInfo
     *
     * Retrieve an existing Ezsignfolder's children IDs
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function objectEzsignfolderGetObjectGetChildrenV1WithHttpInfo($pkiEzsignfolderID)
    {
        $request = $this->objectEzsignfolderGetObjectGetChildrenV1Request($pkiEzsignfolderID);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Client\Model\GenericResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation objectEzsignfolderGetObjectGetChildrenV1Async
     *
     * Retrieve an existing Ezsignfolder's children IDs
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderGetObjectGetChildrenV1Async($pkiEzsignfolderID)
    {
        return $this->objectEzsignfolderGetObjectGetChildrenV1AsyncWithHttpInfo($pkiEzsignfolderID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation objectEzsignfolderGetObjectGetChildrenV1AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfolder's children IDs
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderGetObjectGetChildrenV1AsyncWithHttpInfo($pkiEzsignfolderID)
    {
        $returnType = '';
        $request = $this->objectEzsignfolderGetObjectGetChildrenV1Request($pkiEzsignfolderID);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'objectEzsignfolderGetObjectGetChildrenV1'
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function objectEzsignfolderGetObjectGetChildrenV1Request($pkiEzsignfolderID)
    {
        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling objectEzsignfolderGetObjectGetChildrenV1'
            );
        }

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/getChildren';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation objectEzsignfolderGetObjectV1
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Client\Model\ObjectEzsignfolderGetObjectV1Response|\eZmaxAPI\Client\Model\GenericResponseError
     */
    public function objectEzsignfolderGetObjectV1($pkiEzsignfolderID)
    {
        list($response) = $this->objectEzsignfolderGetObjectV1WithHttpInfo($pkiEzsignfolderID);
        return $response;
    }

    /**
     * Operation objectEzsignfolderGetObjectV1WithHttpInfo
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \eZmaxAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Client\Model\ObjectEzsignfolderGetObjectV1Response|\eZmaxAPI\Client\Model\GenericResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function objectEzsignfolderGetObjectV1WithHttpInfo($pkiEzsignfolderID)
    {
        $request = $this->objectEzsignfolderGetObjectV1Request($pkiEzsignfolderID);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Client\Model\ObjectEzsignfolderGetObjectV1Response' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Client\Model\ObjectEzsignfolderGetObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Client\Model\GenericResponseError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Client\Model\GenericResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Client\Model\ObjectEzsignfolderGetObjectV1Response';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Client\Model\ObjectEzsignfolderGetObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Client\Model\GenericResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation objectEzsignfolderGetObjectV1Async
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderGetObjectV1Async($pkiEzsignfolderID)
    {
        return $this->objectEzsignfolderGetObjectV1AsyncWithHttpInfo($pkiEzsignfolderID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation objectEzsignfolderGetObjectV1AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function objectEzsignfolderGetObjectV1AsyncWithHttpInfo($pkiEzsignfolderID)
    {
        $returnType = '\eZmaxAPI\Client\Model\ObjectEzsignfolderGetObjectV1Response';
        $request = $this->objectEzsignfolderGetObjectV1Request($pkiEzsignfolderID);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'objectEzsignfolderGetObjectV1'
     *
     * @param  int $pkiEzsignfolderID The unique ID of the Ezsignfolder (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function objectEzsignfolderGetObjectV1Request($pkiEzsignfolderID)
    {
        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling objectEzsignfolderGetObjectV1'
            );
        }

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
