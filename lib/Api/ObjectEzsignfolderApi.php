<?php
/**
 * ObjectEzsignfolderApi
 * PHP version 7.4
 *
 * @category Class
 * @package  eZmaxAPI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * eZmax API Definition (Full)
 *
 * This API expose all the functionnalities for the eZmax and eZsign applications.
 *
 * The version of the OpenAPI document: 1.1.18
 * Contact: support-api@ezmax.ca
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace eZmaxAPI\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use eZmaxAPI\ApiException;
use eZmaxAPI\Configuration;
use eZmaxAPI\HeaderSelector;
use eZmaxAPI\ObjectSerializer;
use eZmaxAPI\RequestSignature;

/**
 * ObjectEzsignfolderApi Class Doc Comment
 *
 * @category Class
 * @package  eZmaxAPI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ObjectEzsignfolderApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'ezsignfolderArchiveV1' => [
            'application/json',
        ],
        'ezsignfolderBatchDownloadV1' => [
            'application/json',
        ],
        'ezsignfolderCreateObjectV1' => [
            'application/json',
        ],
        'ezsignfolderCreateObjectV2' => [
            'application/json',
        ],
        'ezsignfolderDeleteObjectV1' => [
            'application/json',
        ],
        'ezsignfolderDisposeEzsignfoldersV1' => [
            'application/json',
        ],
        'ezsignfolderDisposeV1' => [
            'application/json',
        ],
        'ezsignfolderEditObjectV1' => [
            'application/json',
        ],
        'ezsignfolderGetActionableElementsV1' => [
            'application/json',
        ],
        'ezsignfolderGetCommunicationCountV1' => [
            'application/json',
        ],
        'ezsignfolderGetCommunicationListV1' => [
            'application/json',
        ],
        'ezsignfolderGetEzsigndocumentsV1' => [
            'application/json',
        ],
        'ezsignfolderGetEzsignfoldersignerassociationsV1' => [
            'application/json',
        ],
        'ezsignfolderGetEzsignfoldersignerassociationsmineV1' => [
            'application/json',
        ],
        'ezsignfolderGetEzsignsignaturesAutomaticV1' => [
            'application/json',
        ],
        'ezsignfolderGetFormsDataV1' => [
            'application/json',
        ],
        'ezsignfolderGetListV1' => [
            'application/json',
        ],
        'ezsignfolderGetObjectV1' => [
            'application/json',
        ],
        'ezsignfolderGetObjectV2' => [
            'application/json',
        ],
        'ezsignfolderImportEzsignfoldersignerassociationsV1' => [
            'application/json',
        ],
        'ezsignfolderImportEzsigntemplatepackageV1' => [
            'application/json',
        ],
        'ezsignfolderReorderV1' => [
            'application/json',
        ],
        'ezsignfolderSendV1' => [
            'application/json',
        ],
        'ezsignfolderSendV2' => [
            'application/json',
        ],
        'ezsignfolderSendV3' => [
            'application/json',
        ],
        'ezsignfolderUnsendV1' => [
            'application/json',
        ],
    ];

    /** @var array[] $objEzmaxConfig **/
    public const objEzmaxConfig = [
        'ezsignfolderArchiveV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderBatchDownloadV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderCreateObjectV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => true,
        ],
        'ezsignfolderCreateObjectV2' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderDeleteObjectV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderDisposeEzsignfoldersV1' => [
            'permissions' => [
                'ElectronicSignature_DisposalofeZsignfolders',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderDisposeV1' => [
            'permissions' => [
                'ElectronicSignature_DisposalofeZsignfolders',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderEditObjectV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetActionableElementsV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetCommunicationCountV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetCommunicationListV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetEzsigndocumentsV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
                'EzsignSigner',
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetEzsignfoldersignerassociationsV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetEzsignfoldersignerassociationsmineV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
                'EzsignSigner',
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetEzsignsignaturesAutomaticV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetFormsDataV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetListV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderGetObjectV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => true,
        ],
        'ezsignfolderGetObjectV2' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
                'EzsignSigner',
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderImportEzsignfoldersignerassociationsV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderImportEzsigntemplatepackageV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderReorderV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderSendV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => true,
        ],
        'ezsignfolderSendV2' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => true,
        ],
        'ezsignfolderSendV3' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
        'ezsignfolderUnsendV1' => [
            'permissions' => [
                'All',
            ],
            'usertypeextra' => [
            ],
            'apikeyrequire' => true,
            'authorizationsources' => [
                'Authorization',
            ],
            'deprecated' => false,
        ],
    ];
/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation ezsignfolderArchiveV1
     *
     * Archive the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  object $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderArchiveV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderArchiveV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderArchiveV1($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderArchiveV1'][0])
    {
        list($response) = $this->ezsignfolderArchiveV1WithHttpInfo($pkiEzsignfolderID, $body, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderArchiveV1WithHttpInfo
     *
     * Archive the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderArchiveV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderArchiveV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderArchiveV1WithHttpInfo($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderArchiveV1'][0])
    {
        $request = $this->ezsignfolderArchiveV1Request($pkiEzsignfolderID, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderArchiveV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderArchiveV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderArchiveV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderArchiveV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderArchiveV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderArchiveV1Async
     *
     * Archive the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderArchiveV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderArchiveV1Async($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderArchiveV1'][0])
    {
        return $this->ezsignfolderArchiveV1AsyncWithHttpInfo($pkiEzsignfolderID, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderArchiveV1AsyncWithHttpInfo
     *
     * Archive the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderArchiveV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderArchiveV1AsyncWithHttpInfo($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderArchiveV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderArchiveV1Response';
        $request = $this->ezsignfolderArchiveV1Request($pkiEzsignfolderID, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderArchiveV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderArchiveV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderArchiveV1Request($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderArchiveV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderArchiveV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderArchiveV1, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling ezsignfolderArchiveV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderBatchDownloadV1
     *
     * Download multiples files from an Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderBatchDownloadV1Request $ezsignfolderBatchDownloadV1Request ezsignfolderBatchDownloadV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderBatchDownloadV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderBatchDownloadV1($pkiEzsignfolderID, $ezsignfolderBatchDownloadV1Request, string $contentType = self::contentTypes['ezsignfolderBatchDownloadV1'][0])
    {
        list($response) = $this->ezsignfolderBatchDownloadV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderBatchDownloadV1Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderBatchDownloadV1WithHttpInfo
     *
     * Download multiples files from an Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderBatchDownloadV1Request $ezsignfolderBatchDownloadV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderBatchDownloadV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderBatchDownloadV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderBatchDownloadV1Request, string $contentType = self::contentTypes['ezsignfolderBatchDownloadV1'][0])
    {
        $request = $this->ezsignfolderBatchDownloadV1Request($pkiEzsignfolderID, $ezsignfolderBatchDownloadV1Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SplFileObject' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderBatchDownloadV1Async
     *
     * Download multiples files from an Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderBatchDownloadV1Request $ezsignfolderBatchDownloadV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderBatchDownloadV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderBatchDownloadV1Async($pkiEzsignfolderID, $ezsignfolderBatchDownloadV1Request, string $contentType = self::contentTypes['ezsignfolderBatchDownloadV1'][0])
    {
        return $this->ezsignfolderBatchDownloadV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderBatchDownloadV1Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderBatchDownloadV1AsyncWithHttpInfo
     *
     * Download multiples files from an Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderBatchDownloadV1Request $ezsignfolderBatchDownloadV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderBatchDownloadV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderBatchDownloadV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderBatchDownloadV1Request, string $contentType = self::contentTypes['ezsignfolderBatchDownloadV1'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->ezsignfolderBatchDownloadV1Request($pkiEzsignfolderID, $ezsignfolderBatchDownloadV1Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderBatchDownloadV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderBatchDownloadV1Request $ezsignfolderBatchDownloadV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderBatchDownloadV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderBatchDownloadV1Request($pkiEzsignfolderID, $ezsignfolderBatchDownloadV1Request, string $contentType = self::contentTypes['ezsignfolderBatchDownloadV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderBatchDownloadV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderBatchDownloadV1, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'ezsignfolderBatchDownloadV1Request' is set
        if ($ezsignfolderBatchDownloadV1Request === null || (is_array($ezsignfolderBatchDownloadV1Request) && count($ezsignfolderBatchDownloadV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderBatchDownloadV1Request when calling ezsignfolderBatchDownloadV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/batchDownload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/zip', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderBatchDownloadV1Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderBatchDownloadV1Request));
            } else {
                $httpBody = $ezsignfolderBatchDownloadV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderCreateObjectV1
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV1Request[] $ezsignfolderCreateObjectV1Request ezsignfolderCreateObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderCreateObjectV1Response
     * @deprecated
     */
    public function ezsignfolderCreateObjectV1($ezsignfolderCreateObjectV1Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV1'][0])
    {
        list($response) = $this->ezsignfolderCreateObjectV1WithHttpInfo($ezsignfolderCreateObjectV1Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderCreateObjectV1WithHttpInfo
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV1Request[] $ezsignfolderCreateObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderCreateObjectV1Response, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function ezsignfolderCreateObjectV1WithHttpInfo($ezsignfolderCreateObjectV1Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV1'][0])
    {
        $request = $this->ezsignfolderCreateObjectV1Request($ezsignfolderCreateObjectV1Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\eZmaxAPI\Model\EzsignfolderCreateObjectV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderCreateObjectV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderCreateObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderCreateObjectV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderCreateObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderCreateObjectV1Async
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV1Request[] $ezsignfolderCreateObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function ezsignfolderCreateObjectV1Async($ezsignfolderCreateObjectV1Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV1'][0])
    {
        return $this->ezsignfolderCreateObjectV1AsyncWithHttpInfo($ezsignfolderCreateObjectV1Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderCreateObjectV1AsyncWithHttpInfo
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV1Request[] $ezsignfolderCreateObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function ezsignfolderCreateObjectV1AsyncWithHttpInfo($ezsignfolderCreateObjectV1Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderCreateObjectV1Response';
        $request = $this->ezsignfolderCreateObjectV1Request($ezsignfolderCreateObjectV1Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderCreateObjectV1'
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV1Request[] $ezsignfolderCreateObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function ezsignfolderCreateObjectV1Request($ezsignfolderCreateObjectV1Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV1'][0])
    {

        // verify the required parameter 'ezsignfolderCreateObjectV1Request' is set
        if ($ezsignfolderCreateObjectV1Request === null || (is_array($ezsignfolderCreateObjectV1Request) && count($ezsignfolderCreateObjectV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderCreateObjectV1Request when calling ezsignfolderCreateObjectV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderCreateObjectV1Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderCreateObjectV1Request));
            } else {
                $httpBody = $ezsignfolderCreateObjectV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderCreateObjectV2
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV2Request $ezsignfolderCreateObjectV2Request ezsignfolderCreateObjectV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV2'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderCreateObjectV2Response
     */
    public function ezsignfolderCreateObjectV2($ezsignfolderCreateObjectV2Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV2'][0])
    {
        list($response) = $this->ezsignfolderCreateObjectV2WithHttpInfo($ezsignfolderCreateObjectV2Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderCreateObjectV2WithHttpInfo
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV2Request $ezsignfolderCreateObjectV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV2'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderCreateObjectV2Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderCreateObjectV2WithHttpInfo($ezsignfolderCreateObjectV2Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV2'][0])
    {
        $request = $this->ezsignfolderCreateObjectV2Request($ezsignfolderCreateObjectV2Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\eZmaxAPI\Model\EzsignfolderCreateObjectV2Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderCreateObjectV2Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderCreateObjectV2Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderCreateObjectV2Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderCreateObjectV2Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderCreateObjectV2Async
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV2Request $ezsignfolderCreateObjectV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderCreateObjectV2Async($ezsignfolderCreateObjectV2Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV2'][0])
    {
        return $this->ezsignfolderCreateObjectV2AsyncWithHttpInfo($ezsignfolderCreateObjectV2Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderCreateObjectV2AsyncWithHttpInfo
     *
     * Create a new Ezsignfolder
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV2Request $ezsignfolderCreateObjectV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderCreateObjectV2AsyncWithHttpInfo($ezsignfolderCreateObjectV2Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV2'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderCreateObjectV2Response';
        $request = $this->ezsignfolderCreateObjectV2Request($ezsignfolderCreateObjectV2Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderCreateObjectV2'
     *
     * @param  \eZmaxAPI\Model\EzsignfolderCreateObjectV2Request $ezsignfolderCreateObjectV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderCreateObjectV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderCreateObjectV2Request($ezsignfolderCreateObjectV2Request, string $contentType = self::contentTypes['ezsignfolderCreateObjectV2'][0])
    {

        // verify the required parameter 'ezsignfolderCreateObjectV2Request' is set
        if ($ezsignfolderCreateObjectV2Request === null || (is_array($ezsignfolderCreateObjectV2Request) && count($ezsignfolderCreateObjectV2Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderCreateObjectV2Request when calling ezsignfolderCreateObjectV2'
            );
        }


        $resourcePath = '/2/object/ezsignfolder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderCreateObjectV2Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderCreateObjectV2Request));
            } else {
                $httpBody = $ezsignfolderCreateObjectV2Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderDeleteObjectV1
     *
     * Delete an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDeleteObjectV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderDeleteObjectV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderDeleteObjectV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderDeleteObjectV1'][0])
    {
        list($response) = $this->ezsignfolderDeleteObjectV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderDeleteObjectV1WithHttpInfo
     *
     * Delete an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDeleteObjectV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderDeleteObjectV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderDeleteObjectV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderDeleteObjectV1'][0])
    {
        $request = $this->ezsignfolderDeleteObjectV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderDeleteObjectV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderDeleteObjectV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderDeleteObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderDeleteObjectV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderDeleteObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderDeleteObjectV1Async
     *
     * Delete an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDeleteObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderDeleteObjectV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderDeleteObjectV1'][0])
    {
        return $this->ezsignfolderDeleteObjectV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderDeleteObjectV1AsyncWithHttpInfo
     *
     * Delete an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDeleteObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderDeleteObjectV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderDeleteObjectV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderDeleteObjectV1Response';
        $request = $this->ezsignfolderDeleteObjectV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderDeleteObjectV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDeleteObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderDeleteObjectV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderDeleteObjectV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderDeleteObjectV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderDeleteObjectV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'DELETE', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderDisposeEzsignfoldersV1
     *
     * Dispose Ezsignfolders
     *
     * @param  \eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Request $ezsignfolderDisposeEzsignfoldersV1Request ezsignfolderDisposeEzsignfoldersV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderDisposeEzsignfoldersV1($ezsignfolderDisposeEzsignfoldersV1Request, string $contentType = self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'][0])
    {
        list($response) = $this->ezsignfolderDisposeEzsignfoldersV1WithHttpInfo($ezsignfolderDisposeEzsignfoldersV1Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderDisposeEzsignfoldersV1WithHttpInfo
     *
     * Dispose Ezsignfolders
     *
     * @param  \eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Request $ezsignfolderDisposeEzsignfoldersV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderDisposeEzsignfoldersV1WithHttpInfo($ezsignfolderDisposeEzsignfoldersV1Request, string $contentType = self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'][0])
    {
        $request = $this->ezsignfolderDisposeEzsignfoldersV1Request($ezsignfolderDisposeEzsignfoldersV1Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderDisposeEzsignfoldersV1Async
     *
     * Dispose Ezsignfolders
     *
     * @param  \eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Request $ezsignfolderDisposeEzsignfoldersV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderDisposeEzsignfoldersV1Async($ezsignfolderDisposeEzsignfoldersV1Request, string $contentType = self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'][0])
    {
        return $this->ezsignfolderDisposeEzsignfoldersV1AsyncWithHttpInfo($ezsignfolderDisposeEzsignfoldersV1Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderDisposeEzsignfoldersV1AsyncWithHttpInfo
     *
     * Dispose Ezsignfolders
     *
     * @param  \eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Request $ezsignfolderDisposeEzsignfoldersV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderDisposeEzsignfoldersV1AsyncWithHttpInfo($ezsignfolderDisposeEzsignfoldersV1Request, string $contentType = self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Response';
        $request = $this->ezsignfolderDisposeEzsignfoldersV1Request($ezsignfolderDisposeEzsignfoldersV1Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderDisposeEzsignfoldersV1'
     *
     * @param  \eZmaxAPI\Model\EzsignfolderDisposeEzsignfoldersV1Request $ezsignfolderDisposeEzsignfoldersV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderDisposeEzsignfoldersV1Request($ezsignfolderDisposeEzsignfoldersV1Request, string $contentType = self::contentTypes['ezsignfolderDisposeEzsignfoldersV1'][0])
    {

        // verify the required parameter 'ezsignfolderDisposeEzsignfoldersV1Request' is set
        if ($ezsignfolderDisposeEzsignfoldersV1Request === null || (is_array($ezsignfolderDisposeEzsignfoldersV1Request) && count($ezsignfolderDisposeEzsignfoldersV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderDisposeEzsignfoldersV1Request when calling ezsignfolderDisposeEzsignfoldersV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/disposeEzsignfolders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderDisposeEzsignfoldersV1Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderDisposeEzsignfoldersV1Request));
            } else {
                $httpBody = $ezsignfolderDisposeEzsignfoldersV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderDisposeV1
     *
     * Dispose the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  object $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderDisposeV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderDisposeV1($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderDisposeV1'][0])
    {
        list($response) = $this->ezsignfolderDisposeV1WithHttpInfo($pkiEzsignfolderID, $body, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderDisposeV1WithHttpInfo
     *
     * Dispose the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderDisposeV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderDisposeV1WithHttpInfo($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderDisposeV1'][0])
    {
        $request = $this->ezsignfolderDisposeV1Request($pkiEzsignfolderID, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderDisposeV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderDisposeV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderDisposeV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderDisposeV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderDisposeV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderDisposeV1Async
     *
     * Dispose the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderDisposeV1Async($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderDisposeV1'][0])
    {
        return $this->ezsignfolderDisposeV1AsyncWithHttpInfo($pkiEzsignfolderID, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderDisposeV1AsyncWithHttpInfo
     *
     * Dispose the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderDisposeV1AsyncWithHttpInfo($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderDisposeV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderDisposeV1Response';
        $request = $this->ezsignfolderDisposeV1Request($pkiEzsignfolderID, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderDisposeV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderDisposeV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderDisposeV1Request($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderDisposeV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderDisposeV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderDisposeV1, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling ezsignfolderDisposeV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/dispose';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderEditObjectV1
     *
     * Edit an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderEditObjectV1Request $ezsignfolderEditObjectV1Request ezsignfolderEditObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderEditObjectV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderEditObjectV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderEditObjectV1($pkiEzsignfolderID, $ezsignfolderEditObjectV1Request, string $contentType = self::contentTypes['ezsignfolderEditObjectV1'][0])
    {
        list($response) = $this->ezsignfolderEditObjectV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderEditObjectV1Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderEditObjectV1WithHttpInfo
     *
     * Edit an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderEditObjectV1Request $ezsignfolderEditObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderEditObjectV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderEditObjectV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderEditObjectV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderEditObjectV1Request, string $contentType = self::contentTypes['ezsignfolderEditObjectV1'][0])
    {
        $request = $this->ezsignfolderEditObjectV1Request($pkiEzsignfolderID, $ezsignfolderEditObjectV1Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderEditObjectV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderEditObjectV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderEditObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderEditObjectV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderEditObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderEditObjectV1Async
     *
     * Edit an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderEditObjectV1Request $ezsignfolderEditObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderEditObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderEditObjectV1Async($pkiEzsignfolderID, $ezsignfolderEditObjectV1Request, string $contentType = self::contentTypes['ezsignfolderEditObjectV1'][0])
    {
        return $this->ezsignfolderEditObjectV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderEditObjectV1Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderEditObjectV1AsyncWithHttpInfo
     *
     * Edit an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderEditObjectV1Request $ezsignfolderEditObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderEditObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderEditObjectV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderEditObjectV1Request, string $contentType = self::contentTypes['ezsignfolderEditObjectV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderEditObjectV1Response';
        $request = $this->ezsignfolderEditObjectV1Request($pkiEzsignfolderID, $ezsignfolderEditObjectV1Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderEditObjectV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderEditObjectV1Request $ezsignfolderEditObjectV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderEditObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderEditObjectV1Request($pkiEzsignfolderID, $ezsignfolderEditObjectV1Request, string $contentType = self::contentTypes['ezsignfolderEditObjectV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderEditObjectV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderEditObjectV1, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'ezsignfolderEditObjectV1Request' is set
        if ($ezsignfolderEditObjectV1Request === null || (is_array($ezsignfolderEditObjectV1Request) && count($ezsignfolderEditObjectV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderEditObjectV1Request when calling ezsignfolderEditObjectV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderEditObjectV1Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderEditObjectV1Request));
            } else {
                $httpBody = $ezsignfolderEditObjectV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'PUT', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetActionableElementsV1
     *
     * Retrieve actionable elements for the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetActionableElementsV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetActionableElementsV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetActionableElementsV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetActionableElementsV1'][0])
    {
        list($response) = $this->ezsignfolderGetActionableElementsV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetActionableElementsV1WithHttpInfo
     *
     * Retrieve actionable elements for the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetActionableElementsV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetActionableElementsV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetActionableElementsV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetActionableElementsV1'][0])
    {
        $request = $this->ezsignfolderGetActionableElementsV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetActionableElementsV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetActionableElementsV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetActionableElementsV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetActionableElementsV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetActionableElementsV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetActionableElementsV1Async
     *
     * Retrieve actionable elements for the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetActionableElementsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetActionableElementsV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetActionableElementsV1'][0])
    {
        return $this->ezsignfolderGetActionableElementsV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetActionableElementsV1AsyncWithHttpInfo
     *
     * Retrieve actionable elements for the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetActionableElementsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetActionableElementsV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetActionableElementsV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetActionableElementsV1Response';
        $request = $this->ezsignfolderGetActionableElementsV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetActionableElementsV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetActionableElementsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetActionableElementsV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetActionableElementsV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetActionableElementsV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetActionableElementsV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/getActionableElements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetCommunicationCountV1
     *
     * Retrieve Communication count
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationCountV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetCommunicationCountV1Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetCommunicationCountV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationCountV1'][0])
    {
        list($response) = $this->ezsignfolderGetCommunicationCountV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetCommunicationCountV1WithHttpInfo
     *
     * Retrieve Communication count
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationCountV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetCommunicationCountV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetCommunicationCountV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationCountV1'][0])
    {
        $request = $this->ezsignfolderGetCommunicationCountV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetCommunicationCountV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetCommunicationCountV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetCommunicationCountV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetCommunicationCountV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetCommunicationCountV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetCommunicationCountV1Async
     *
     * Retrieve Communication count
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationCountV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetCommunicationCountV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationCountV1'][0])
    {
        return $this->ezsignfolderGetCommunicationCountV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetCommunicationCountV1AsyncWithHttpInfo
     *
     * Retrieve Communication count
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationCountV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetCommunicationCountV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationCountV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetCommunicationCountV1Response';
        $request = $this->ezsignfolderGetCommunicationCountV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetCommunicationCountV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationCountV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetCommunicationCountV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationCountV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetCommunicationCountV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetCommunicationCountV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationCount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetCommunicationListV1
     *
     * Retrieve Communication list
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationListV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetCommunicationListV1Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetCommunicationListV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationListV1'][0])
    {
        list($response) = $this->ezsignfolderGetCommunicationListV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetCommunicationListV1WithHttpInfo
     *
     * Retrieve Communication list
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationListV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetCommunicationListV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetCommunicationListV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationListV1'][0])
    {
        $request = $this->ezsignfolderGetCommunicationListV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetCommunicationListV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetCommunicationListV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetCommunicationListV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetCommunicationListV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetCommunicationListV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetCommunicationListV1Async
     *
     * Retrieve Communication list
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationListV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetCommunicationListV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationListV1'][0])
    {
        return $this->ezsignfolderGetCommunicationListV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetCommunicationListV1AsyncWithHttpInfo
     *
     * Retrieve Communication list
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationListV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetCommunicationListV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationListV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetCommunicationListV1Response';
        $request = $this->ezsignfolderGetCommunicationListV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetCommunicationListV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetCommunicationListV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetCommunicationListV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetCommunicationListV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetCommunicationListV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetCommunicationListV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/getCommunicationList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetEzsigndocumentsV1
     *
     * Retrieve an existing Ezsignfolder&#39;s Ezsigndocuments
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsigndocumentsV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetEzsigndocumentsV1Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetEzsigndocumentsV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsigndocumentsV1'][0])
    {
        list($response) = $this->ezsignfolderGetEzsigndocumentsV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetEzsigndocumentsV1WithHttpInfo
     *
     * Retrieve an existing Ezsignfolder&#39;s Ezsigndocuments
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsigndocumentsV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetEzsigndocumentsV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetEzsigndocumentsV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsigndocumentsV1'][0])
    {
        $request = $this->ezsignfolderGetEzsigndocumentsV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetEzsigndocumentsV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetEzsigndocumentsV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetEzsigndocumentsV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetEzsigndocumentsV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetEzsigndocumentsV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetEzsigndocumentsV1Async
     *
     * Retrieve an existing Ezsignfolder&#39;s Ezsigndocuments
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsigndocumentsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetEzsigndocumentsV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsigndocumentsV1'][0])
    {
        return $this->ezsignfolderGetEzsigndocumentsV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetEzsigndocumentsV1AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfolder&#39;s Ezsigndocuments
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsigndocumentsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetEzsigndocumentsV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsigndocumentsV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetEzsigndocumentsV1Response';
        $request = $this->ezsignfolderGetEzsigndocumentsV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetEzsigndocumentsV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsigndocumentsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetEzsigndocumentsV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsigndocumentsV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetEzsigndocumentsV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetEzsigndocumentsV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsigndocuments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetEzsignfoldersignerassociationsV1
     *
     * Retrieve an existing Ezsignfolder&#39;s Ezsignfoldersignerassociations
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsV1Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'][0])
    {
        list($response) = $this->ezsignfolderGetEzsignfoldersignerassociationsV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetEzsignfoldersignerassociationsV1WithHttpInfo
     *
     * Retrieve an existing Ezsignfolder&#39;s Ezsignfoldersignerassociations
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'][0])
    {
        $request = $this->ezsignfolderGetEzsignfoldersignerassociationsV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetEzsignfoldersignerassociationsV1Async
     *
     * Retrieve an existing Ezsignfolder&#39;s Ezsignfoldersignerassociations
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'][0])
    {
        return $this->ezsignfolderGetEzsignfoldersignerassociationsV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetEzsignfoldersignerassociationsV1AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfolder&#39;s Ezsignfoldersignerassociations
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsV1Response';
        $request = $this->ezsignfolderGetEzsignfoldersignerassociationsV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetEzsignfoldersignerassociationsV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetEzsignfoldersignerassociationsV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetEzsignfoldersignerassociationsV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsignfoldersignerassociations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetEzsignfoldersignerassociationsmineV1
     *
     * Retrieve your own Ezsignfoldersignerassociations from an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsmineV1Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsmineV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'][0])
    {
        list($response) = $this->ezsignfolderGetEzsignfoldersignerassociationsmineV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetEzsignfoldersignerassociationsmineV1WithHttpInfo
     *
     * Retrieve your own Ezsignfoldersignerassociations from an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsmineV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsmineV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'][0])
    {
        $request = $this->ezsignfolderGetEzsignfoldersignerassociationsmineV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsmineV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsmineV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsmineV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsmineV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsmineV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetEzsignfoldersignerassociationsmineV1Async
     *
     * Retrieve your own Ezsignfoldersignerassociations from an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsmineV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'][0])
    {
        return $this->ezsignfolderGetEzsignfoldersignerassociationsmineV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetEzsignfoldersignerassociationsmineV1AsyncWithHttpInfo
     *
     * Retrieve your own Ezsignfoldersignerassociations from an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsmineV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetEzsignfoldersignerassociationsmineV1Response';
        $request = $this->ezsignfolderGetEzsignfoldersignerassociationsmineV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetEzsignfoldersignerassociationsmineV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetEzsignfoldersignerassociationsmineV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignfoldersignerassociationsmineV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetEzsignfoldersignerassociationsmineV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetEzsignfoldersignerassociationsmineV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsignfoldersignerassociationsmine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetEzsignsignaturesAutomaticV1
     *
     * Retrieve an existing Ezsignfolder&#39;s automatic Ezsignsignatures
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetEzsignsignaturesAutomaticV1Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetEzsignsignaturesAutomaticV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'][0])
    {
        list($response) = $this->ezsignfolderGetEzsignsignaturesAutomaticV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetEzsignsignaturesAutomaticV1WithHttpInfo
     *
     * Retrieve an existing Ezsignfolder&#39;s automatic Ezsignsignatures
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetEzsignsignaturesAutomaticV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetEzsignsignaturesAutomaticV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'][0])
    {
        $request = $this->ezsignfolderGetEzsignsignaturesAutomaticV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetEzsignsignaturesAutomaticV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetEzsignsignaturesAutomaticV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetEzsignsignaturesAutomaticV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetEzsignsignaturesAutomaticV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetEzsignsignaturesAutomaticV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetEzsignsignaturesAutomaticV1Async
     *
     * Retrieve an existing Ezsignfolder&#39;s automatic Ezsignsignatures
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetEzsignsignaturesAutomaticV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'][0])
    {
        return $this->ezsignfolderGetEzsignsignaturesAutomaticV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetEzsignsignaturesAutomaticV1AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfolder&#39;s automatic Ezsignsignatures
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetEzsignsignaturesAutomaticV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetEzsignsignaturesAutomaticV1Response';
        $request = $this->ezsignfolderGetEzsignsignaturesAutomaticV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetEzsignsignaturesAutomaticV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetEzsignsignaturesAutomaticV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetEzsignsignaturesAutomaticV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetEzsignsignaturesAutomaticV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetEzsignsignaturesAutomaticV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/getEzsignsignaturesAutomatic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetFormsDataV1
     *
     * Retrieve an existing Ezsignfolder&#39;s forms data
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetFormsDataV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetFormsDataV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetFormsDataV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetFormsDataV1'][0])
    {
        list($response) = $this->ezsignfolderGetFormsDataV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetFormsDataV1WithHttpInfo
     *
     * Retrieve an existing Ezsignfolder&#39;s forms data
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetFormsDataV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetFormsDataV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetFormsDataV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetFormsDataV1'][0])
    {
        $request = $this->ezsignfolderGetFormsDataV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetFormsDataV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetFormsDataV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetFormsDataV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetFormsDataV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetFormsDataV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetFormsDataV1Async
     *
     * Retrieve an existing Ezsignfolder&#39;s forms data
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetFormsDataV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetFormsDataV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetFormsDataV1'][0])
    {
        return $this->ezsignfolderGetFormsDataV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetFormsDataV1AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfolder&#39;s forms data
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetFormsDataV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetFormsDataV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetFormsDataV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetFormsDataV1Response';
        $request = $this->ezsignfolderGetFormsDataV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetFormsDataV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetFormsDataV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetFormsDataV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetFormsDataV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetFormsDataV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetFormsDataV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/getFormsData';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/zip', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetListV1
     *
     * Retrieve Ezsignfolder list
     *
     * @param  string $eOrderBy Specify how you want the results to be sorted (optional)
     * @param  int $iRowMax iRowMax (optional, default to 10000)
     * @param  int $iRowOffset iRowOffset (optional, default to 0)
     * @param  HeaderAcceptLanguage $acceptLanguage acceptLanguage (optional)
     * @param  string $sFilter sFilter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetListV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetListV1Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetListV1($eOrderBy = null, $iRowMax = 10000, $iRowOffset = 0, $acceptLanguage = null, $sFilter = null, string $contentType = self::contentTypes['ezsignfolderGetListV1'][0])
    {
        list($response) = $this->ezsignfolderGetListV1WithHttpInfo($eOrderBy, $iRowMax, $iRowOffset, $acceptLanguage, $sFilter, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetListV1WithHttpInfo
     *
     * Retrieve Ezsignfolder list
     *
     * @param  string $eOrderBy Specify how you want the results to be sorted (optional)
     * @param  int $iRowMax (optional, default to 10000)
     * @param  int $iRowOffset (optional, default to 0)
     * @param  HeaderAcceptLanguage $acceptLanguage (optional)
     * @param  string $sFilter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetListV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetListV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetListV1WithHttpInfo($eOrderBy = null, $iRowMax = 10000, $iRowOffset = 0, $acceptLanguage = null, $sFilter = null, string $contentType = self::contentTypes['ezsignfolderGetListV1'][0])
    {
        $request = $this->ezsignfolderGetListV1Request($eOrderBy, $iRowMax, $iRowOffset, $acceptLanguage, $sFilter, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetListV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetListV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetListV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetListV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetListV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetListV1Async
     *
     * Retrieve Ezsignfolder list
     *
     * @param  string $eOrderBy Specify how you want the results to be sorted (optional)
     * @param  int $iRowMax (optional, default to 10000)
     * @param  int $iRowOffset (optional, default to 0)
     * @param  HeaderAcceptLanguage $acceptLanguage (optional)
     * @param  string $sFilter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetListV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetListV1Async($eOrderBy = null, $iRowMax = 10000, $iRowOffset = 0, $acceptLanguage = null, $sFilter = null, string $contentType = self::contentTypes['ezsignfolderGetListV1'][0])
    {
        return $this->ezsignfolderGetListV1AsyncWithHttpInfo($eOrderBy, $iRowMax, $iRowOffset, $acceptLanguage, $sFilter, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetListV1AsyncWithHttpInfo
     *
     * Retrieve Ezsignfolder list
     *
     * @param  string $eOrderBy Specify how you want the results to be sorted (optional)
     * @param  int $iRowMax (optional, default to 10000)
     * @param  int $iRowOffset (optional, default to 0)
     * @param  HeaderAcceptLanguage $acceptLanguage (optional)
     * @param  string $sFilter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetListV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetListV1AsyncWithHttpInfo($eOrderBy = null, $iRowMax = 10000, $iRowOffset = 0, $acceptLanguage = null, $sFilter = null, string $contentType = self::contentTypes['ezsignfolderGetListV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetListV1Response';
        $request = $this->ezsignfolderGetListV1Request($eOrderBy, $iRowMax, $iRowOffset, $acceptLanguage, $sFilter, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetListV1'
     *
     * @param  string $eOrderBy Specify how you want the results to be sorted (optional)
     * @param  int $iRowMax (optional, default to 10000)
     * @param  int $iRowOffset (optional, default to 0)
     * @param  HeaderAcceptLanguage $acceptLanguage (optional)
     * @param  string $sFilter (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetListV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetListV1Request($eOrderBy = null, $iRowMax = 10000, $iRowOffset = 0, $acceptLanguage = null, $sFilter = null, string $contentType = self::contentTypes['ezsignfolderGetListV1'][0])
    {


        if ($iRowMax !== null && $iRowMax > 10000) {
            throw new \InvalidArgumentException('invalid value for "$iRowMax" when calling ObjectEzsignfolderApi.ezsignfolderGetListV1, must be smaller than or equal to 10000.');
        }
        if ($iRowMax !== null && $iRowMax < 1) {
            throw new \InvalidArgumentException('invalid value for "$iRowMax" when calling ObjectEzsignfolderApi.ezsignfolderGetListV1, must be bigger than or equal to 1.');
        }
        
        if ($iRowOffset !== null && $iRowOffset < 0) {
            throw new \InvalidArgumentException('invalid value for "$iRowOffset" when calling ObjectEzsignfolderApi.ezsignfolderGetListV1, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/1/object/ezsignfolder/getList';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $eOrderBy,
            'eOrderBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $iRowMax,
            'iRowMax', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $iRowOffset,
            'iRowOffset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sFilter,
            'sFilter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($acceptLanguage !== null) {
            $headerParams['Accept-Language'] = ObjectSerializer::toHeaderValue($acceptLanguage);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetObjectV1
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetObjectV1Response|\eZmaxAPI\Model\CommonResponseError
     * @deprecated
     */
    public function ezsignfolderGetObjectV1($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV1'][0])
    {
        list($response) = $this->ezsignfolderGetObjectV1WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetObjectV1WithHttpInfo
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetObjectV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function ezsignfolderGetObjectV1WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV1'][0])
    {
        $request = $this->ezsignfolderGetObjectV1Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetObjectV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetObjectV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetObjectV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetObjectV1Async
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function ezsignfolderGetObjectV1Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV1'][0])
    {
        return $this->ezsignfolderGetObjectV1AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetObjectV1AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function ezsignfolderGetObjectV1AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetObjectV1Response';
        $request = $this->ezsignfolderGetObjectV1Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetObjectV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function ezsignfolderGetObjectV1Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetObjectV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetObjectV1, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderGetObjectV2
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV2'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderGetObjectV2Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderGetObjectV2($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV2'][0])
    {
        list($response) = $this->ezsignfolderGetObjectV2WithHttpInfo($pkiEzsignfolderID, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderGetObjectV2WithHttpInfo
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV2'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderGetObjectV2Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderGetObjectV2WithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV2'][0])
    {
        $request = $this->ezsignfolderGetObjectV2Request($pkiEzsignfolderID, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderGetObjectV2Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderGetObjectV2Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderGetObjectV2Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderGetObjectV2Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderGetObjectV2Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderGetObjectV2Async
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetObjectV2Async($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV2'][0])
    {
        return $this->ezsignfolderGetObjectV2AsyncWithHttpInfo($pkiEzsignfolderID, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderGetObjectV2AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderGetObjectV2AsyncWithHttpInfo($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV2'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderGetObjectV2Response';
        $request = $this->ezsignfolderGetObjectV2Request($pkiEzsignfolderID, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderGetObjectV2'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderGetObjectV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderGetObjectV2Request($pkiEzsignfolderID, string $contentType = self::contentTypes['ezsignfolderGetObjectV2'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderGetObjectV2'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderGetObjectV2, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/2/object/ezsignfolder/{pkiEzsignfolderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'GET', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderImportEzsignfoldersignerassociationsV1
     *
     * Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Request $ezsignfolderImportEzsignfoldersignerassociationsV1Request ezsignfolderImportEzsignfoldersignerassociationsV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderImportEzsignfoldersignerassociationsV1($pkiEzsignfolderID, $ezsignfolderImportEzsignfoldersignerassociationsV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'][0])
    {
        list($response) = $this->ezsignfolderImportEzsignfoldersignerassociationsV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderImportEzsignfoldersignerassociationsV1Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderImportEzsignfoldersignerassociationsV1WithHttpInfo
     *
     * Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Request $ezsignfolderImportEzsignfoldersignerassociationsV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderImportEzsignfoldersignerassociationsV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderImportEzsignfoldersignerassociationsV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'][0])
    {
        $request = $this->ezsignfolderImportEzsignfoldersignerassociationsV1Request($pkiEzsignfolderID, $ezsignfolderImportEzsignfoldersignerassociationsV1Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderImportEzsignfoldersignerassociationsV1Async
     *
     * Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Request $ezsignfolderImportEzsignfoldersignerassociationsV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderImportEzsignfoldersignerassociationsV1Async($pkiEzsignfolderID, $ezsignfolderImportEzsignfoldersignerassociationsV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'][0])
    {
        return $this->ezsignfolderImportEzsignfoldersignerassociationsV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderImportEzsignfoldersignerassociationsV1Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderImportEzsignfoldersignerassociationsV1AsyncWithHttpInfo
     *
     * Import an existing Ezsignfoldersignerassociation into this Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Request $ezsignfolderImportEzsignfoldersignerassociationsV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderImportEzsignfoldersignerassociationsV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderImportEzsignfoldersignerassociationsV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Response';
        $request = $this->ezsignfolderImportEzsignfoldersignerassociationsV1Request($pkiEzsignfolderID, $ezsignfolderImportEzsignfoldersignerassociationsV1Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderImportEzsignfoldersignerassociationsV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsignfoldersignerassociationsV1Request $ezsignfolderImportEzsignfoldersignerassociationsV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderImportEzsignfoldersignerassociationsV1Request($pkiEzsignfolderID, $ezsignfolderImportEzsignfoldersignerassociationsV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsignfoldersignerassociationsV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderImportEzsignfoldersignerassociationsV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderImportEzsignfoldersignerassociationsV1, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'ezsignfolderImportEzsignfoldersignerassociationsV1Request' is set
        if ($ezsignfolderImportEzsignfoldersignerassociationsV1Request === null || (is_array($ezsignfolderImportEzsignfoldersignerassociationsV1Request) && count($ezsignfolderImportEzsignfoldersignerassociationsV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderImportEzsignfoldersignerassociationsV1Request when calling ezsignfolderImportEzsignfoldersignerassociationsV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/importEzsignfoldersignerassociations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderImportEzsignfoldersignerassociationsV1Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderImportEzsignfoldersignerassociationsV1Request));
            } else {
                $httpBody = $ezsignfolderImportEzsignfoldersignerassociationsV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderImportEzsigntemplatepackageV1
     *
     * Import an Ezsigntemplatepackage in the Ezsignfolder.
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Request $ezsignfolderImportEzsigntemplatepackageV1Request ezsignfolderImportEzsigntemplatepackageV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderImportEzsigntemplatepackageV1($pkiEzsignfolderID, $ezsignfolderImportEzsigntemplatepackageV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'][0])
    {
        list($response) = $this->ezsignfolderImportEzsigntemplatepackageV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderImportEzsigntemplatepackageV1Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderImportEzsigntemplatepackageV1WithHttpInfo
     *
     * Import an Ezsigntemplatepackage in the Ezsignfolder.
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Request $ezsignfolderImportEzsigntemplatepackageV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderImportEzsigntemplatepackageV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderImportEzsigntemplatepackageV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'][0])
    {
        $request = $this->ezsignfolderImportEzsigntemplatepackageV1Request($pkiEzsignfolderID, $ezsignfolderImportEzsigntemplatepackageV1Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderImportEzsigntemplatepackageV1Async
     *
     * Import an Ezsigntemplatepackage in the Ezsignfolder.
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Request $ezsignfolderImportEzsigntemplatepackageV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderImportEzsigntemplatepackageV1Async($pkiEzsignfolderID, $ezsignfolderImportEzsigntemplatepackageV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'][0])
    {
        return $this->ezsignfolderImportEzsigntemplatepackageV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderImportEzsigntemplatepackageV1Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderImportEzsigntemplatepackageV1AsyncWithHttpInfo
     *
     * Import an Ezsigntemplatepackage in the Ezsignfolder.
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Request $ezsignfolderImportEzsigntemplatepackageV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderImportEzsigntemplatepackageV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderImportEzsigntemplatepackageV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Response';
        $request = $this->ezsignfolderImportEzsigntemplatepackageV1Request($pkiEzsignfolderID, $ezsignfolderImportEzsigntemplatepackageV1Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderImportEzsigntemplatepackageV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderImportEzsigntemplatepackageV1Request $ezsignfolderImportEzsigntemplatepackageV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderImportEzsigntemplatepackageV1Request($pkiEzsignfolderID, $ezsignfolderImportEzsigntemplatepackageV1Request, string $contentType = self::contentTypes['ezsignfolderImportEzsigntemplatepackageV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderImportEzsigntemplatepackageV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderImportEzsigntemplatepackageV1, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'ezsignfolderImportEzsigntemplatepackageV1Request' is set
        if ($ezsignfolderImportEzsigntemplatepackageV1Request === null || (is_array($ezsignfolderImportEzsigntemplatepackageV1Request) && count($ezsignfolderImportEzsigntemplatepackageV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderImportEzsigntemplatepackageV1Request when calling ezsignfolderImportEzsigntemplatepackageV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/importEzsigntemplatepackage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderImportEzsigntemplatepackageV1Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderImportEzsigntemplatepackageV1Request));
            } else {
                $httpBody = $ezsignfolderImportEzsigntemplatepackageV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderReorderV1
     *
     * Reorder Ezsigndocuments in the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderReorderV1Request $ezsignfolderReorderV1Request ezsignfolderReorderV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderReorderV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderReorderV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderReorderV1($pkiEzsignfolderID, $ezsignfolderReorderV1Request, string $contentType = self::contentTypes['ezsignfolderReorderV1'][0])
    {
        list($response) = $this->ezsignfolderReorderV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderReorderV1Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderReorderV1WithHttpInfo
     *
     * Reorder Ezsigndocuments in the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderReorderV1Request $ezsignfolderReorderV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderReorderV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderReorderV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderReorderV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderReorderV1Request, string $contentType = self::contentTypes['ezsignfolderReorderV1'][0])
    {
        $request = $this->ezsignfolderReorderV1Request($pkiEzsignfolderID, $ezsignfolderReorderV1Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderReorderV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderReorderV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderReorderV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderReorderV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderReorderV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderReorderV1Async
     *
     * Reorder Ezsigndocuments in the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderReorderV1Request $ezsignfolderReorderV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderReorderV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderReorderV1Async($pkiEzsignfolderID, $ezsignfolderReorderV1Request, string $contentType = self::contentTypes['ezsignfolderReorderV1'][0])
    {
        return $this->ezsignfolderReorderV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderReorderV1Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderReorderV1AsyncWithHttpInfo
     *
     * Reorder Ezsigndocuments in the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderReorderV1Request $ezsignfolderReorderV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderReorderV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderReorderV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderReorderV1Request, string $contentType = self::contentTypes['ezsignfolderReorderV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderReorderV1Response';
        $request = $this->ezsignfolderReorderV1Request($pkiEzsignfolderID, $ezsignfolderReorderV1Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderReorderV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderReorderV1Request $ezsignfolderReorderV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderReorderV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderReorderV1Request($pkiEzsignfolderID, $ezsignfolderReorderV1Request, string $contentType = self::contentTypes['ezsignfolderReorderV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderReorderV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderReorderV1, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'ezsignfolderReorderV1Request' is set
        if ($ezsignfolderReorderV1Request === null || (is_array($ezsignfolderReorderV1Request) && count($ezsignfolderReorderV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderReorderV1Request when calling ezsignfolderReorderV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/reorder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderReorderV1Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderReorderV1Request));
            } else {
                $httpBody = $ezsignfolderReorderV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderSendV1
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV1Request $ezsignfolderSendV1Request ezsignfolderSendV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderSendV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     * @deprecated
     */
    public function ezsignfolderSendV1($pkiEzsignfolderID, $ezsignfolderSendV1Request, string $contentType = self::contentTypes['ezsignfolderSendV1'][0])
    {
        list($response) = $this->ezsignfolderSendV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV1Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderSendV1WithHttpInfo
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV1Request $ezsignfolderSendV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderSendV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function ezsignfolderSendV1WithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV1Request, string $contentType = self::contentTypes['ezsignfolderSendV1'][0])
    {
        $request = $this->ezsignfolderSendV1Request($pkiEzsignfolderID, $ezsignfolderSendV1Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderSendV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderSendV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderSendV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderSendV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderSendV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderSendV1Async
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV1Request $ezsignfolderSendV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function ezsignfolderSendV1Async($pkiEzsignfolderID, $ezsignfolderSendV1Request, string $contentType = self::contentTypes['ezsignfolderSendV1'][0])
    {
        return $this->ezsignfolderSendV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV1Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderSendV1AsyncWithHttpInfo
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV1Request $ezsignfolderSendV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function ezsignfolderSendV1AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV1Request, string $contentType = self::contentTypes['ezsignfolderSendV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderSendV1Response';
        $request = $this->ezsignfolderSendV1Request($pkiEzsignfolderID, $ezsignfolderSendV1Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderSendV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV1Request $ezsignfolderSendV1Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function ezsignfolderSendV1Request($pkiEzsignfolderID, $ezsignfolderSendV1Request, string $contentType = self::contentTypes['ezsignfolderSendV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderSendV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderSendV1, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'ezsignfolderSendV1Request' is set
        if ($ezsignfolderSendV1Request === null || (is_array($ezsignfolderSendV1Request) && count($ezsignfolderSendV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderSendV1Request when calling ezsignfolderSendV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderSendV1Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderSendV1Request));
            } else {
                $httpBody = $ezsignfolderSendV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderSendV2
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV2Request $ezsignfolderSendV2Request ezsignfolderSendV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV2'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderSendV2Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     * @deprecated
     */
    public function ezsignfolderSendV2($pkiEzsignfolderID, $ezsignfolderSendV2Request, string $contentType = self::contentTypes['ezsignfolderSendV2'][0])
    {
        list($response) = $this->ezsignfolderSendV2WithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV2Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderSendV2WithHttpInfo
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV2Request $ezsignfolderSendV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV2'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderSendV2Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function ezsignfolderSendV2WithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV2Request, string $contentType = self::contentTypes['ezsignfolderSendV2'][0])
    {
        $request = $this->ezsignfolderSendV2Request($pkiEzsignfolderID, $ezsignfolderSendV2Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderSendV2Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderSendV2Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderSendV2Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderSendV2Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderSendV2Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderSendV2Async
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV2Request $ezsignfolderSendV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function ezsignfolderSendV2Async($pkiEzsignfolderID, $ezsignfolderSendV2Request, string $contentType = self::contentTypes['ezsignfolderSendV2'][0])
    {
        return $this->ezsignfolderSendV2AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV2Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderSendV2AsyncWithHttpInfo
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV2Request $ezsignfolderSendV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function ezsignfolderSendV2AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV2Request, string $contentType = self::contentTypes['ezsignfolderSendV2'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderSendV2Response';
        $request = $this->ezsignfolderSendV2Request($pkiEzsignfolderID, $ezsignfolderSendV2Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderSendV2'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV2Request $ezsignfolderSendV2Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function ezsignfolderSendV2Request($pkiEzsignfolderID, $ezsignfolderSendV2Request, string $contentType = self::contentTypes['ezsignfolderSendV2'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderSendV2'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderSendV2, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'ezsignfolderSendV2Request' is set
        if ($ezsignfolderSendV2Request === null || (is_array($ezsignfolderSendV2Request) && count($ezsignfolderSendV2Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderSendV2Request when calling ezsignfolderSendV2'
            );
        }


        $resourcePath = '/2/object/ezsignfolder/{pkiEzsignfolderID}/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderSendV2Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderSendV2Request));
            } else {
                $httpBody = $ezsignfolderSendV2Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderSendV3
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV3Request $ezsignfolderSendV3Request ezsignfolderSendV3Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV3'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderSendV3Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderSendV3($pkiEzsignfolderID, $ezsignfolderSendV3Request, string $contentType = self::contentTypes['ezsignfolderSendV3'][0])
    {
        list($response) = $this->ezsignfolderSendV3WithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV3Request, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderSendV3WithHttpInfo
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV3Request $ezsignfolderSendV3Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV3'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderSendV3Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderSendV3WithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV3Request, string $contentType = self::contentTypes['ezsignfolderSendV3'][0])
    {
        $request = $this->ezsignfolderSendV3Request($pkiEzsignfolderID, $ezsignfolderSendV3Request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderSendV3Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderSendV3Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderSendV3Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderSendV3Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderSendV3Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderSendV3Async
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV3Request $ezsignfolderSendV3Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderSendV3Async($pkiEzsignfolderID, $ezsignfolderSendV3Request, string $contentType = self::contentTypes['ezsignfolderSendV3'][0])
    {
        return $this->ezsignfolderSendV3AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV3Request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderSendV3AsyncWithHttpInfo
     *
     * Send the Ezsignfolder to the signatories for signature
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV3Request $ezsignfolderSendV3Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderSendV3AsyncWithHttpInfo($pkiEzsignfolderID, $ezsignfolderSendV3Request, string $contentType = self::contentTypes['ezsignfolderSendV3'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderSendV3Response';
        $request = $this->ezsignfolderSendV3Request($pkiEzsignfolderID, $ezsignfolderSendV3Request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderSendV3'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  \eZmaxAPI\Model\EzsignfolderSendV3Request $ezsignfolderSendV3Request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderSendV3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderSendV3Request($pkiEzsignfolderID, $ezsignfolderSendV3Request, string $contentType = self::contentTypes['ezsignfolderSendV3'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderSendV3'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderSendV3, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'ezsignfolderSendV3Request' is set
        if ($ezsignfolderSendV3Request === null || (is_array($ezsignfolderSendV3Request) && count($ezsignfolderSendV3Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfolderSendV3Request when calling ezsignfolderSendV3'
            );
        }


        $resourcePath = '/3/object/ezsignfolder/{pkiEzsignfolderID}/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ezsignfolderSendV3Request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ezsignfolderSendV3Request));
            } else {
                $httpBody = $ezsignfolderSendV3Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfolderUnsendV1
     *
     * Unsend the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID pkiEzsignfolderID (required)
     * @param  object $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderUnsendV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfolderUnsendV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfolderUnsendV1($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderUnsendV1'][0])
    {
        list($response) = $this->ezsignfolderUnsendV1WithHttpInfo($pkiEzsignfolderID, $body, $contentType);
        return $response;
    }

    /**
     * Operation ezsignfolderUnsendV1WithHttpInfo
     *
     * Unsend the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderUnsendV1'] to see the possible values for this operation
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfolderUnsendV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfolderUnsendV1WithHttpInfo($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderUnsendV1'][0])
    {
        $request = $this->ezsignfolderUnsendV1Request($pkiEzsignfolderID, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfolderUnsendV1Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\EzsignfolderUnsendV1Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfolderUnsendV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\eZmaxAPI\Model\CommonResponseError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfolderUnsendV1Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfolderUnsendV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfolderUnsendV1Async
     *
     * Unsend the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderUnsendV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderUnsendV1Async($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderUnsendV1'][0])
    {
        return $this->ezsignfolderUnsendV1AsyncWithHttpInfo($pkiEzsignfolderID, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfolderUnsendV1AsyncWithHttpInfo
     *
     * Unsend the Ezsignfolder
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderUnsendV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfolderUnsendV1AsyncWithHttpInfo($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderUnsendV1'][0])
    {
        $returnType = '\eZmaxAPI\Model\EzsignfolderUnsendV1Response';
        $request = $this->ezsignfolderUnsendV1Request($pkiEzsignfolderID, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfolderUnsendV1'
     *
     * @param  int $pkiEzsignfolderID (required)
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['ezsignfolderUnsendV1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ezsignfolderUnsendV1Request($pkiEzsignfolderID, $body, string $contentType = self::contentTypes['ezsignfolderUnsendV1'][0])
    {

        // verify the required parameter 'pkiEzsignfolderID' is set
        if ($pkiEzsignfolderID === null || (is_array($pkiEzsignfolderID) && count($pkiEzsignfolderID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfolderID when calling ezsignfolderUnsendV1'
            );
        }
        if ($pkiEzsignfolderID < 0) {
            throw new \InvalidArgumentException('invalid value for "$pkiEzsignfolderID" when calling ObjectEzsignfolderApi.ezsignfolderUnsendV1, must be bigger than or equal to 0.');
        }
        
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling ezsignfolderUnsendV1'
            );
        }


        $resourcePath = '/1/object/ezsignfolder/{pkiEzsignfolderID}/unsend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfolderID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfolderID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfolderID),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        if ($apiKey !== null) {
            $secret = $this->config->getSecret();
            if ($secret !== '') {
                //Let's sign the request
                $headers = array_merge($headers, RequestSignature::getHeadersV1($apiKey, $secret, 'POST', $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''), $httpBody));
            }		
        }

        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
