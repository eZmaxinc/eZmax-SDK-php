<?php
/**
 * EzsignfoldersignerassociationApi
 * PHP version 7.2
 *
 * @category Class
 * @package  eZmaxAPI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * eZmax API Definition
 *
 * This API expose all the functionnalities for the eZmax and eZsign application.  We provide SDKs for customers. They are generated using OpenAPI codegen, we encourage customers to use them as we also provide samples for them.  You can choose to build your own implementation manually or can use any compatible OpenAPI 3.0 generator like Swagger Codegen, OpenAPI codegen or any commercial generators.  If you need helping understanding how to use this API, don't waste too much time looking for it. Contact support-api@ezmax.ca, we're here to help. We are developpers so we know programmers don't like bad documentation. If you don't find what you need in the documentation, let us know, we'll improve it and put you rapidly up on track.
 *
 * The version of the OpenAPI document: 1.0.18
 * Contact: support-api@ezmax.ca
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace eZmaxAPI\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use eZmaxAPI\ApiException;
use eZmaxAPI\Configuration;
use eZmaxAPI\HeaderSelector;
use eZmaxAPI\ObjectSerializer;

/**
 * EzsignfoldersignerassociationApi Class Doc Comment
 *
 * @category Class
 * @package  eZmaxAPI
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EzsignfoldersignerassociationApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation ezsignfoldersignerassociationCreateObjectV1
     *
     * Create a new Ezsignfoldersignerassociation
     *
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Request[] $ezsignfoldersignerassociationCreateObjectV1Request ezsignfoldersignerassociationCreateObjectV1Request (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Response
     */
    public function ezsignfoldersignerassociationCreateObjectV1($ezsignfoldersignerassociationCreateObjectV1Request)
    {
        list($response) = $this->ezsignfoldersignerassociationCreateObjectV1WithHttpInfo($ezsignfoldersignerassociationCreateObjectV1Request);
        return $response;
    }

    /**
     * Operation ezsignfoldersignerassociationCreateObjectV1WithHttpInfo
     *
     * Create a new Ezsignfoldersignerassociation
     *
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Request[] $ezsignfoldersignerassociationCreateObjectV1Request (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfoldersignerassociationCreateObjectV1WithHttpInfo($ezsignfoldersignerassociationCreateObjectV1Request)
    {
        $request = $this->ezsignfoldersignerassociationCreateObjectV1Request($ezsignfoldersignerassociationCreateObjectV1Request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Response' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Response';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfoldersignerassociationCreateObjectV1Async
     *
     * Create a new Ezsignfoldersignerassociation
     *
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Request[] $ezsignfoldersignerassociationCreateObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationCreateObjectV1Async($ezsignfoldersignerassociationCreateObjectV1Request)
    {
        return $this->ezsignfoldersignerassociationCreateObjectV1AsyncWithHttpInfo($ezsignfoldersignerassociationCreateObjectV1Request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfoldersignerassociationCreateObjectV1AsyncWithHttpInfo
     *
     * Create a new Ezsignfoldersignerassociation
     *
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Request[] $ezsignfoldersignerassociationCreateObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationCreateObjectV1AsyncWithHttpInfo($ezsignfoldersignerassociationCreateObjectV1Request)
    {
        $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Response';
        $request = $this->ezsignfoldersignerassociationCreateObjectV1Request($ezsignfoldersignerassociationCreateObjectV1Request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfoldersignerassociationCreateObjectV1'
     *
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationCreateObjectV1Request[] $ezsignfoldersignerassociationCreateObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ezsignfoldersignerassociationCreateObjectV1Request($ezsignfoldersignerassociationCreateObjectV1Request)
    {
        // verify the required parameter 'ezsignfoldersignerassociationCreateObjectV1Request' is set
        if ($ezsignfoldersignerassociationCreateObjectV1Request === null || (is_array($ezsignfoldersignerassociationCreateObjectV1Request) && count($ezsignfoldersignerassociationCreateObjectV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfoldersignerassociationCreateObjectV1Request when calling ezsignfoldersignerassociationCreateObjectV1'
            );
        }

        $resourcePath = '/1/object/ezsignfoldersignerassociation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($ezsignfoldersignerassociationCreateObjectV1Request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($ezsignfoldersignerassociationCreateObjectV1Request));
            } else {
                $httpBody = $ezsignfoldersignerassociationCreateObjectV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfoldersignerassociationDeleteObjectV1
     *
     * Delete an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfoldersignerassociationDeleteObjectV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfoldersignerassociationDeleteObjectV1($pkiEzsignfoldersignerassociationID)
    {
        list($response) = $this->ezsignfoldersignerassociationDeleteObjectV1WithHttpInfo($pkiEzsignfoldersignerassociationID);
        return $response;
    }

    /**
     * Operation ezsignfoldersignerassociationDeleteObjectV1WithHttpInfo
     *
     * Delete an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfoldersignerassociationDeleteObjectV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfoldersignerassociationDeleteObjectV1WithHttpInfo($pkiEzsignfoldersignerassociationID)
    {
        $request = $this->ezsignfoldersignerassociationDeleteObjectV1Request($pkiEzsignfoldersignerassociationID);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfoldersignerassociationDeleteObjectV1Response' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfoldersignerassociationDeleteObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationDeleteObjectV1Response';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfoldersignerassociationDeleteObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfoldersignerassociationDeleteObjectV1Async
     *
     * Delete an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationDeleteObjectV1Async($pkiEzsignfoldersignerassociationID)
    {
        return $this->ezsignfoldersignerassociationDeleteObjectV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfoldersignerassociationDeleteObjectV1AsyncWithHttpInfo
     *
     * Delete an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationDeleteObjectV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID)
    {
        $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationDeleteObjectV1Response';
        $request = $this->ezsignfoldersignerassociationDeleteObjectV1Request($pkiEzsignfoldersignerassociationID);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfoldersignerassociationDeleteObjectV1'
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ezsignfoldersignerassociationDeleteObjectV1Request($pkiEzsignfoldersignerassociationID)
    {
        // verify the required parameter 'pkiEzsignfoldersignerassociationID' is set
        if ($pkiEzsignfoldersignerassociationID === null || (is_array($pkiEzsignfoldersignerassociationID) && count($pkiEzsignfoldersignerassociationID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfoldersignerassociationID when calling ezsignfoldersignerassociationDeleteObjectV1'
            );
        }

        $resourcePath = '/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfoldersignerassociationID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfoldersignerassociationID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfoldersignerassociationID),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfoldersignerassociationEditObjectV1
     *
     * Modify an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Request $ezsignfoldersignerassociationEditObjectV1Request ezsignfoldersignerassociationEditObjectV1Request (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfoldersignerassociationEditObjectV1($pkiEzsignfoldersignerassociationID, $ezsignfoldersignerassociationEditObjectV1Request)
    {
        list($response) = $this->ezsignfoldersignerassociationEditObjectV1WithHttpInfo($pkiEzsignfoldersignerassociationID, $ezsignfoldersignerassociationEditObjectV1Request);
        return $response;
    }

    /**
     * Operation ezsignfoldersignerassociationEditObjectV1WithHttpInfo
     *
     * Modify an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Request $ezsignfoldersignerassociationEditObjectV1Request (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfoldersignerassociationEditObjectV1WithHttpInfo($pkiEzsignfoldersignerassociationID, $ezsignfoldersignerassociationEditObjectV1Request)
    {
        $request = $this->ezsignfoldersignerassociationEditObjectV1Request($pkiEzsignfoldersignerassociationID, $ezsignfoldersignerassociationEditObjectV1Request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Response' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Response';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfoldersignerassociationEditObjectV1Async
     *
     * Modify an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Request $ezsignfoldersignerassociationEditObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationEditObjectV1Async($pkiEzsignfoldersignerassociationID, $ezsignfoldersignerassociationEditObjectV1Request)
    {
        return $this->ezsignfoldersignerassociationEditObjectV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID, $ezsignfoldersignerassociationEditObjectV1Request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfoldersignerassociationEditObjectV1AsyncWithHttpInfo
     *
     * Modify an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Request $ezsignfoldersignerassociationEditObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationEditObjectV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID, $ezsignfoldersignerassociationEditObjectV1Request)
    {
        $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Response';
        $request = $this->ezsignfoldersignerassociationEditObjectV1Request($pkiEzsignfoldersignerassociationID, $ezsignfoldersignerassociationEditObjectV1Request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfoldersignerassociationEditObjectV1'
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     * @param  \eZmaxAPI\Model\EzsignfoldersignerassociationEditObjectV1Request $ezsignfoldersignerassociationEditObjectV1Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ezsignfoldersignerassociationEditObjectV1Request($pkiEzsignfoldersignerassociationID, $ezsignfoldersignerassociationEditObjectV1Request)
    {
        // verify the required parameter 'pkiEzsignfoldersignerassociationID' is set
        if ($pkiEzsignfoldersignerassociationID === null || (is_array($pkiEzsignfoldersignerassociationID) && count($pkiEzsignfoldersignerassociationID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfoldersignerassociationID when calling ezsignfoldersignerassociationEditObjectV1'
            );
        }
        // verify the required parameter 'ezsignfoldersignerassociationEditObjectV1Request' is set
        if ($ezsignfoldersignerassociationEditObjectV1Request === null || (is_array($ezsignfoldersignerassociationEditObjectV1Request) && count($ezsignfoldersignerassociationEditObjectV1Request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ezsignfoldersignerassociationEditObjectV1Request when calling ezsignfoldersignerassociationEditObjectV1'
            );
        }

        $resourcePath = '/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfoldersignerassociationID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfoldersignerassociationID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfoldersignerassociationID),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($ezsignfoldersignerassociationEditObjectV1Request)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($ezsignfoldersignerassociationEditObjectV1Request));
            } else {
                $httpBody = $ezsignfoldersignerassociationEditObjectV1Request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfoldersignerassociationGetInPersonLoginUrlV1
     *
     * Retrieve a Login Url to allow In-Person signing
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfoldersignerassociationGetInPersonLoginUrlV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfoldersignerassociationGetInPersonLoginUrlV1($pkiEzsignfoldersignerassociationID)
    {
        list($response) = $this->ezsignfoldersignerassociationGetInPersonLoginUrlV1WithHttpInfo($pkiEzsignfoldersignerassociationID);
        return $response;
    }

    /**
     * Operation ezsignfoldersignerassociationGetInPersonLoginUrlV1WithHttpInfo
     *
     * Retrieve a Login Url to allow In-Person signing
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfoldersignerassociationGetInPersonLoginUrlV1Response|\eZmaxAPI\Model\CommonResponseError|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfoldersignerassociationGetInPersonLoginUrlV1WithHttpInfo($pkiEzsignfoldersignerassociationID)
    {
        $request = $this->ezsignfoldersignerassociationGetInPersonLoginUrlV1Request($pkiEzsignfoldersignerassociationID);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfoldersignerassociationGetInPersonLoginUrlV1Response' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfoldersignerassociationGetInPersonLoginUrlV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationGetInPersonLoginUrlV1Response';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfoldersignerassociationGetInPersonLoginUrlV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfoldersignerassociationGetInPersonLoginUrlV1Async
     *
     * Retrieve a Login Url to allow In-Person signing
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationGetInPersonLoginUrlV1Async($pkiEzsignfoldersignerassociationID)
    {
        return $this->ezsignfoldersignerassociationGetInPersonLoginUrlV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfoldersignerassociationGetInPersonLoginUrlV1AsyncWithHttpInfo
     *
     * Retrieve a Login Url to allow In-Person signing
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationGetInPersonLoginUrlV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID)
    {
        $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationGetInPersonLoginUrlV1Response';
        $request = $this->ezsignfoldersignerassociationGetInPersonLoginUrlV1Request($pkiEzsignfoldersignerassociationID);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfoldersignerassociationGetInPersonLoginUrlV1'
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ezsignfoldersignerassociationGetInPersonLoginUrlV1Request($pkiEzsignfoldersignerassociationID)
    {
        // verify the required parameter 'pkiEzsignfoldersignerassociationID' is set
        if ($pkiEzsignfoldersignerassociationID === null || (is_array($pkiEzsignfoldersignerassociationID) && count($pkiEzsignfoldersignerassociationID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfoldersignerassociationID when calling ezsignfoldersignerassociationGetInPersonLoginUrlV1'
            );
        }

        $resourcePath = '/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}/getInPersonLoginUrl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfoldersignerassociationID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfoldersignerassociationID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfoldersignerassociationID),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfoldersignerassociationGetObjectGetChildrenV1
     *
     * Retrieve an existing Ezsignfoldersignerassociation's children IDs
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ezsignfoldersignerassociationGetObjectGetChildrenV1($pkiEzsignfoldersignerassociationID)
    {
        $this->ezsignfoldersignerassociationGetObjectGetChildrenV1WithHttpInfo($pkiEzsignfoldersignerassociationID);
    }

    /**
     * Operation ezsignfoldersignerassociationGetObjectGetChildrenV1WithHttpInfo
     *
     * Retrieve an existing Ezsignfoldersignerassociation's children IDs
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfoldersignerassociationGetObjectGetChildrenV1WithHttpInfo($pkiEzsignfoldersignerassociationID)
    {
        $request = $this->ezsignfoldersignerassociationGetObjectGetChildrenV1Request($pkiEzsignfoldersignerassociationID);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfoldersignerassociationGetObjectGetChildrenV1Async
     *
     * Retrieve an existing Ezsignfoldersignerassociation's children IDs
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationGetObjectGetChildrenV1Async($pkiEzsignfoldersignerassociationID)
    {
        return $this->ezsignfoldersignerassociationGetObjectGetChildrenV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfoldersignerassociationGetObjectGetChildrenV1AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfoldersignerassociation's children IDs
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationGetObjectGetChildrenV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID)
    {
        $returnType = '';
        $request = $this->ezsignfoldersignerassociationGetObjectGetChildrenV1Request($pkiEzsignfoldersignerassociationID);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfoldersignerassociationGetObjectGetChildrenV1'
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ezsignfoldersignerassociationGetObjectGetChildrenV1Request($pkiEzsignfoldersignerassociationID)
    {
        // verify the required parameter 'pkiEzsignfoldersignerassociationID' is set
        if ($pkiEzsignfoldersignerassociationID === null || (is_array($pkiEzsignfoldersignerassociationID) && count($pkiEzsignfoldersignerassociationID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfoldersignerassociationID when calling ezsignfoldersignerassociationGetObjectGetChildrenV1'
            );
        }

        $resourcePath = '/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}/getChildren';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfoldersignerassociationID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfoldersignerassociationID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfoldersignerassociationID),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ezsignfoldersignerassociationGetObjectV1
     *
     * Retrieve an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \eZmaxAPI\Model\EzsignfoldersignerassociationGetObjectV1Response|\eZmaxAPI\Model\CommonResponseError
     */
    public function ezsignfoldersignerassociationGetObjectV1($pkiEzsignfoldersignerassociationID)
    {
        list($response) = $this->ezsignfoldersignerassociationGetObjectV1WithHttpInfo($pkiEzsignfoldersignerassociationID);
        return $response;
    }

    /**
     * Operation ezsignfoldersignerassociationGetObjectV1WithHttpInfo
     *
     * Retrieve an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \eZmaxAPI\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \eZmaxAPI\Model\EzsignfoldersignerassociationGetObjectV1Response|\eZmaxAPI\Model\CommonResponseError, HTTP status code, HTTP response headers (array of strings)
     */
    public function ezsignfoldersignerassociationGetObjectV1WithHttpInfo($pkiEzsignfoldersignerassociationID)
    {
        $request = $this->ezsignfoldersignerassociationGetObjectV1Request($pkiEzsignfoldersignerassociationID);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\eZmaxAPI\Model\EzsignfoldersignerassociationGetObjectV1Response' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\EzsignfoldersignerassociationGetObjectV1Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\eZmaxAPI\Model\CommonResponseError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\eZmaxAPI\Model\CommonResponseError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationGetObjectV1Response';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\EzsignfoldersignerassociationGetObjectV1Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\eZmaxAPI\Model\CommonResponseError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ezsignfoldersignerassociationGetObjectV1Async
     *
     * Retrieve an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationGetObjectV1Async($pkiEzsignfoldersignerassociationID)
    {
        return $this->ezsignfoldersignerassociationGetObjectV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ezsignfoldersignerassociationGetObjectV1AsyncWithHttpInfo
     *
     * Retrieve an existing Ezsignfoldersignerassociation
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ezsignfoldersignerassociationGetObjectV1AsyncWithHttpInfo($pkiEzsignfoldersignerassociationID)
    {
        $returnType = '\eZmaxAPI\Model\EzsignfoldersignerassociationGetObjectV1Response';
        $request = $this->ezsignfoldersignerassociationGetObjectV1Request($pkiEzsignfoldersignerassociationID);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ezsignfoldersignerassociationGetObjectV1'
     *
     * @param  int $pkiEzsignfoldersignerassociationID The unique ID of the Ezsignfoldersignerassociation (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ezsignfoldersignerassociationGetObjectV1Request($pkiEzsignfoldersignerassociationID)
    {
        // verify the required parameter 'pkiEzsignfoldersignerassociationID' is set
        if ($pkiEzsignfoldersignerassociationID === null || (is_array($pkiEzsignfoldersignerassociationID) && count($pkiEzsignfoldersignerassociationID) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pkiEzsignfoldersignerassociationID when calling ezsignfoldersignerassociationGetObjectV1'
            );
        }

        $resourcePath = '/1/object/ezsignfoldersignerassociation/{pkiEzsignfoldersignerassociationID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($pkiEzsignfoldersignerassociationID !== null) {
            $resourcePath = str_replace(
                '{' . 'pkiEzsignfoldersignerassociationID' . '}',
                ObjectSerializer::toPathValue($pkiEzsignfoldersignerassociationID),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
